/*
给你二叉树的根节点T和一个整数目标和targetSum，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/path-sum-ii

输入为二叉树先序序列（-1表示无孩子）

示例1：
root  =  [5  4  11  7  -1  -1  2  -1  -1  -1  8  13  -1  -1  4  5  -1  -1  1  -1  -1]
targetSum  =  22  
输出:
[5  4  11  2][5  8  4  5]

示例2：
root  =  [1  2  -1  -1  3  -1  -1]
targetSum  =  5  
输出:[]

示例3：
root  =  [1  2  -1  -1  -1]
targetSum  =  0  
输出:[]
*/

#include  <stdio.h>
#include  <stdlib.h>
#include  <string.h>
#include  <assert.h>
#include  <stddef.h>
#define  TRUE  1
#define  FALSE  0
#define  OK  1
#define  ERROR  0
#define  INFEASIBLE  -1
#define  OVERFLOW  -2
#define  LIST_INIT_SIZE  100
#define  STACK_INIT_SIZE  100
typedef  int  Status;

typedef  struct  BiTNode{
        int        data;
        struct  BiTNode  *lchild,*rchild;
}BiTNode,  *BiTree;

//输入先序序列，创建二叉树
void  CreateBiTree(BiTree  &T)
{        int  ch;
        scanf("%d",&ch);
        if    (ch    ==  -1)    T    =    NULL;
        else
        {        T  =  (BiTNode  *)malloc(sizeof(BiTNode));
                T->data  =  ch;
                CreateBiTree(T->lchild);
                CreateBiTree(T->rchild);
        }
}

#define  MAX_VERTEX_NUM  20
typedef  int  VertexType  ;
VertexType  Path[MAX_VERTEX_NUM];//存放输出的顶点序列  

void  Solution(BiTree  T,int  targetSum)
{ 
    static int temp=0;
    if(T==NULL) return ;
    Path[temp++]=T->data;
    targetSum-=T->data;
    if(T->lchild==NULL&&T->rchild==NULL&&targetSum==0){
            for( int i=0;i<temp;i++) printf("%d ",Path[i]);
            printf("\n");
            temp--;
            targetSum+=T->data;
            return ;
    }
    Solution(T->lchild,targetSum);
    Solution(T->rchild,targetSum);
    temp-=1;
    targetSum-=T->data;



}

int  main()
{        BiTree  T;
              CreateBiTree(T);
              int  targetSum;
              scanf("%d",&targetSum);
                Solution(T,targetSum);
        return  1;  
}